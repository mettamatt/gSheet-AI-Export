/**
 * Adds a custom menu to the Google Sheets UI upon opening the spreadsheet.
 * The menu contains an option to export the spreadsheet data and formulas as JSON.
 */
function onOpen() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const menuEntries = [{ name: "Export for AI (JSON)", functionName: "saveAsJson" }];
  ss.addMenu("Export Tools", menuEntries);
}

/**
 * Exports the entire spreadsheet's data, formulas, and additional metadata into a downloadable JSON file.
 * The JSON excludes null fields and empty cells to minimize file size.
 */
function saveAsJson() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ss.getSheets();

  // Initialize the main JSON object with metadata and explanation
  let spreadsheetData = {
    explanation: "This JSON file was generated by converting a Google Sheet. It contains all data, formulas, and metadata from the spreadsheet, excluding empty cells and null fields.",
    spreadsheet_metadata: {
      spreadsheet_name: ss.getName(),
      export_timestamp: new Date().toISOString(),
      total_sheets: sheets.length,
      total_rows: 0,
      total_columns: 0,
      total_cells: 0,
      total_formulas: 0
    },
    sheets: []
  };

  // Iterate through each sheet to gather data, formulas, and metadata
  sheets.forEach(sheet => {
    const sheetName = sheet.getName();
    const sheetId = sheet.getSheetId();
    const dataRange = sheet.getDataRange();
    const numRows = dataRange.getNumRows();
    const numColumns = dataRange.getNumColumns();

    // Fetch all required data in bulk to optimize performance
    const values = dataRange.getValues();
    const formulas = dataRange.getFormulas();
    const comments = dataRange.getComments();
    const notes = dataRange.getNotes();
    const validations = dataRange.getDataValidations();
    const richTextValues = dataRange.getRichTextValues();

    // Fetch merged ranges and create a map for quick lookup
    const merges = dataRange.getMergedRanges();
    const mergedCellsMap = {};
    merges.forEach(mergeRange => {
      const mergeAddress = mergeRange.getA1Notation();
      const startRow = mergeRange.getRow();
      const startCol = mergeRange.getColumn();
      const numRowsMerge = mergeRange.getNumRows();
      const numColsMerge = mergeRange.getNumColumns();

      // Map all cells within the merged range to the merge address
      for (let rowOffset = 0; rowOffset < numRowsMerge; rowOffset++) {
        for (let colOffset = 0; colOffset < numColsMerge; colOffset++) {
          const row = startRow + rowOffset;
          const col = startCol + colOffset;
          const cellAddress = getCellAddress(row, col);
          mergedCellsMap[cellAddress] = mergeAddress;
        }
      }
    });

    // Count the number of formulas in the sheet
    let formulaCount = 0;
    formulas.forEach(row => {
      row.forEach(cell => {
        if (cell && cell.trim() !== "") {
          formulaCount++;
        }
      });
    });

    // Update overall spreadsheet metadata
    spreadsheetData.spreadsheet_metadata.total_rows += numRows;
    spreadsheetData.spreadsheet_metadata.total_columns += numColumns;
    spreadsheetData.spreadsheet_metadata.total_cells += numRows * numColumns;
    spreadsheetData.spreadsheet_metadata.total_formulas += formulaCount;

    // Construct the cells array
    let cells = [];
    for (let rowIndex = 0; rowIndex < numRows; rowIndex++) {
      for (let colIndex = 0; colIndex < numColumns; colIndex++) {
        const rowNumber = rowIndex + 1;
        const colNumber = colIndex + 1;
        const cellAddress = getCellAddress(rowNumber, colNumber);

        // Retrieve data from pre-fetched arrays
        const value = values[rowIndex][colIndex];
        const formula = formulas[rowIndex][colIndex];
        const comment = comments[rowIndex][colIndex];
        const note = notes[rowIndex][colIndex];
        const validation = validations[rowIndex][colIndex];
        const richTextValue = richTextValues[rowIndex][colIndex];

        // Get data validation criteria
        let validationCriteria = null;
        if (validation) {
          validationCriteria = {
            criteriaType: validation.getCriteriaType(),
            criteriaValues: validation.getCriteriaValues()
          };
        }

        // Check if the cell is part of a merged range
        let mergeInfo = null;
        if (mergedCellsMap[cellAddress]) {
          mergeInfo = {
            isMerged: true,
            mergeRange: mergedCellsMap[cellAddress]
          };
        }

        // Get hyperlink if it exists
        let hyperlink = null;
        if (richTextValue && typeof richTextValue.getLinkUrl === 'function') {
          hyperlink = richTextValue.getLinkUrl();
        }

        // Check if the cell is not empty (has any meaningful data)
        const hasData = (
          (value !== null && value !== '') ||
          (formula && formula.trim() !== '') ||
          (comment && comment.trim() !== '') ||
          (note && note.trim() !== '') ||
          validationCriteria ||
          mergeInfo ||
          (hyperlink && hyperlink.trim() !== '')
        );

        if (hasData) {
          // Construct cell data object excluding null fields
          let cellData = {
            cell_address: cellAddress,
            value: value,
            formula: formula,
            comment: comment,
            note: note,
            data_validation: validationCriteria,
            merge_info: mergeInfo,
            hyperlink: hyperlink
          };

          // Remove fields with null, undefined, or empty string values
          for (let key in cellData) {
            if (
              cellData[key] === null ||
              cellData[key] === undefined ||
              cellData[key] === ''
            ) {
              delete cellData[key];
            }
          }

          cells.push(cellData);
        }
      }
    }

    // Only include the sheet if it has any cells with data
    if (cells.length > 0) {
      // Construct sheet-specific data and metadata
      let sheetData = {
        sheet_name: sheetName,
        sheet_id: sheetId,
        sheet_index: sheet.getIndex(),
        sheet_metadata: {
          num_rows: numRows,
          num_columns: numColumns,
          num_cells: numRows * numColumns,
          num_formulas: formulaCount,
          protected: sheet.isSheetHidden() ? "Hidden" : "Visible"
        },
        cells: cells
      };

      spreadsheetData.sheets.push(sheetData);
    }
  });

  // Convert the JSON object to a formatted string
  const jsonContent = JSON.stringify(spreadsheetData, null, 2);

  // Create the downloadable JSON file as a blob
  const blob = Utilities.newBlob(jsonContent, MimeType.JSON, `${ss.getName()}_data.json`);

  // Create a download link via HTML output
  const base64Data = Utilities.base64Encode(blob.getBytes());
  const htmlOutput = HtmlService.createHtmlOutput(
    `<html>
      <body>
        <a href="data:application/json;base64,${base64Data}" download="${ss.getName()}_data.json">
          Click here to download the JSON file
        </a>
      </body>
    </html>`
  );
  SpreadsheetApp.getUi().showModalDialog(htmlOutput, 'Download JSON');
}

/**
 * Converts a column number to its corresponding letter(s).
 * @param {number} column The column number.
 * @returns {string} The column letter(s).
 */
function columnToLetter(column) {
  let temp, letter = '';
  while (column > 0) {
    temp = (column - 1) % 26;
    letter = String.fromCharCode(temp + 65) + letter;
    column = (column - temp - 1) / 26;
  }
  return letter;
}

/**
 * Generates the A1 notation for a cell given its row and column numbers.
 * @param {number} row The row number.
 * @param {number} col The column number.
 * @returns {string} The cell's A1 notation.
 */
function getCellAddress(row, col) {
  const columnLetter = columnToLetter(col);
  return `${columnLetter}${row}`;
}
